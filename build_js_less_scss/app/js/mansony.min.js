function isVisibleElm(elm) {
  if (!elm) { return false; }
  const getBounding = elm.getBoundingClientRect();
  return getBounding.height > 0;
}
function getVisibleElms(elms) {
  const tmpArr = [].slice.call(elms);
  const visibleElm = tmpArr.filter(isVisibleElm);
  return visibleElm;
}

class Mansony {
  constructor({
    parent        = document.querySelector('#mansony'),
    links         = document.querySelectorAll('[data-mansony-link]'),
    active        = 'is-active',
    margin        = 20,
    responsive    = {
      1023: {
        columns: 4,
        margin: 20
      },
      767: {
        columns: 3,
        margin: 20
      },
      575: {
        columns: 2,
        margin: 20
      },
      0: {
        columns: 1,
        margin: 20
      }
    },
    fadeDuration  = {
      in: 300,
      out: 0
    }
  } = {}) {
    this.parent           = parent;
    this.links            = Array.from(links);
    this.active           = active;
    this.margin           = margin;
    this.responsive       = responsive;
    this.fadeDuration     = fadeDuration;
    this.elements         = Array.from(this.parent.querySelectorAll('[data-mansony-el]'));
    this.activeElements   = this.elements;
    this.columns          = 1;
    this.dataLink         = 'all';
    this.winWidth         = window.innerWidth;

    this.init();
  }

  orderElements() {
    this.isRunning = true;
    this.margin = this.columnsCount(this.responsive)['margin'];
    this.activeElements = Array.from(getVisibleElms(this.parent.querySelectorAll('[data-mansony-el]')));
    let {parent, activeElements, columns, blockWidth, margin} = this;
    let arrayRectHeight   = activeElements.reduce((acc, el, id) => {
      let columnsHeight   = this.sumArrHeight(acc, columns);
      let positionX       = (id % columns) * (blockWidth + margin);
      let rectHeight      = (id - columns >= 0) ? (columnsHeight[id % columns] + (margin * Math.floor(id / columns))) : 0;

      el.style.transform  = `translate3d(${positionX}px, ${rectHeight}px, 0)`;

      acc.push(el.offsetHeight);
      return acc;
    }, []);

    let columnsMaxHeight    = this.sumArrHeight(arrayRectHeight, columns);
    columnsMaxHeight        = Math.max(...columnsMaxHeight);
    let parentHeight        = columnsMaxHeight + (margin * (Math.ceil(activeElements.length / columns) - 1));
    parent.style.height     = `${parentHeight}px`;
    parent.classList.add('loaded');
    window.dispatchEvent(new Event('resize'));
  }

  handleFilterClick(ev, element) {
    ev.preventDefault();
    let {links, active} = this;

    if(element.dataset.mansonyLink === this.dataLink) {
      return;
    } else {
      this.dataLink = element.dataset.mansonyLink;
      links.forEach(el => {
        el.isEqualNode(element) ? el.classList.add(active) : el.classList.remove(active);
      });
      this.filterElements(() => {
        this.orderElements();
      });
    }
  }

  resize() {
    const resize = ('onorientationchange' in window) ? 'orientationchange' : 'resize';
    window.addEventListener(resize, () => {
      clearTimeout(window.sortableResize);
      window.sortableResize = setTimeout(() => {
        this.winWidth = window.innerWidth;
        this.setBlockWidth(() => {
          this.orderElements();
        });
      }, 300);
    });
  }
  scroll() {
    window.addEventListener('scroll', () => {
      clearTimeout(window.sortableResize);
      window.sortableResize = setTimeout(() => {
        this.winWidth = window.innerWidth;
        this.setBlockWidth(() => {
          this.orderElements();
        });
      }, 300);
    });
  }

  init() {
    let {parent, links, active} = this;

    links.forEach((el, id) => {
      if(id === 0) {
        el.classList.add(active);
        this.dataLink = el.dataset.mansonyLink;
      }
      el.addEventListener('click', ev => {
        this.handleFilterClick(ev, el);
      });
    });

    this.setBlockWidth();

    // window.addEventListener('load', () => {
      this.filterElements(() => {
        this.orderElements();
      });
      parent.style.opacity = 1;
    // });

    this.resize();
    this.scroll();
  }

  setBlockWidth(callback) {
    this.margin = this.columnsCount(this.responsive)['margin'];
    let {parent, elements, margin, responsive} = this;
    let columns         = this.columns = this.columnsCount(responsive)['columns'];
    let blockWidth       = this.blockWidth = (parent.clientWidth - (margin * (columns - 1))) / columns;

    elements.forEach(el => {
      el.style.width = `${blockWidth}px`;
    });
    callback && callback();
  }

  filterElements(callback) {
    let {elements, dataLink, fadeDuration} = this;

    this.activeElements = elements.filter(el => {
      if(dataLink === 'all') {
        this.fadeIn(el, fadeDuration.in, callback);
        return true;
      } else {
        if(el.dataset.mansonyEl !== dataLink) {
          this.fadeOut(el, fadeDuration.out, callback);
          return false;
        } else {
          this.fadeIn(el, fadeDuration.in, callback);
          return true;
        }
      }
    });
  }

  sumArrHeight(arr, col) {
    return arr.reduce((acc, val, id) => {
      let cle = id % col;
      if(!acc[cle]) {
        acc[cle] = 0;
      }
      acc[cle] = acc[cle] + val;
      return acc;
    }, []);
  }

  columnsCount(obj) {
    let { winWidth } = this;
    return Object.entries(obj).reduce((acc, val) => {
      if(winWidth > val[0] && val[0] >= Math.max(acc['width'])) {
        return { width: val[0], columns: val[1]['columns'], margin: val[1]['margin'] };
      } else {
        return acc;
      }
    }, { width: 0, columns: 4, margin: 20 });
  }

  fadeIn(el, duration, callback) {
    duration = duration || 300;
    let opacity   = parseFloat(window.getComputedStyle(el, null).getPropertyValue('opacity')),
        interval  = 16,
        gap       = interval / duration;

    el.style.display = 'block';

    function animation() {
      opacity += gap;

      if(opacity <= 1) {
        el.style.opacity = opacity;
        requestAnimationFrame(animation);
      } else {
        if (el.classList.contains('hidden')) {
          el.style.opacity = 0;
        } else {
          el.style.opacity = 1;
        }
        callback && callback();
      }
    }
    requestAnimationFrame(animation);
  }

  fadeOut(el, duration, callback) {
    duration = duration || 0;
    let opacity   = parseFloat(window.getComputedStyle(el, null).getPropertyValue('opacity')),
        interval  = 16,
        gap       = duration ? (interval / duration) : 1;

    function animation() {
      opacity -= gap;

      if(opacity >= 0) {
        el.style.opacity = opacity;
        requestAnimationFrame(animation);
      } else {
        el.style.opacity = 0;
        el.style.display = 'none';
        callback && callback();
      }
    }
    requestAnimationFrame(animation);
  }
}
